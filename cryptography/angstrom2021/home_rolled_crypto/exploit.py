#!/usr/bin/python
import binascii
from random import choice
from pwn import *

r = remote('crypto.2021.chall.actf.co', 21602)

class Cipher:
    BLOCK_SIZE = 16
    ROUNDS = 3
    def __init__(self, key):
        assert(len(key) == self.BLOCK_SIZE*self.ROUNDS)
        self.key = key

    def __block_encrypt(self, block):
        enc = int.from_bytes(block, "big")
        for i in range(self.ROUNDS):
            k = int.from_bytes(self.key[i*self.BLOCK_SIZE:(i+1)*self.BLOCK_SIZE], "big")
            enc &= k
            enc ^= k
        return hex(enc)[2:].rjust(self.BLOCK_SIZE*2, "0")


    def __pad(self, msg):
        if len(msg) % self.BLOCK_SIZE != 0:
            return msg + (bytes([0]) * (self.BLOCK_SIZE - (len(msg) % self.BLOCK_SIZE)))
        else:
            return msg
    
    def encrypt(self, msg):
        m = self.__pad(msg)
        e = ""
        for i in range(0, len(m), self.BLOCK_SIZE):
            e += self.__block_encrypt(m[i:i+self.BLOCK_SIZE])
        return e.encode()
        
def find_key(x, y):
	assert len(x) == 8
	
	o1 = ''
	o2 = ''
	o3 = ''
	for i in range(8):
		if (x[i] == '0' and y[i] == '0'):
			o1 += '0'
			o2 += '0'
			o3 += '0'
		elif (x[i] == '0' and y[i] == '1'):
			o1 += '1'
			o2 += '1'
			o3 += '1'
		elif (x[i] == '1' and y[i] == '0'):
			raise Exception('compare 1 to 0. this can\'t happen')
		else:
			o1 += '0'
			o2 += '0'
			o3 += '1'
	return (int(o1, 2).to_bytes(1, 'big'), int(o2, 2).to_bytes(1, 'big'), int(o3, 2).to_bytes(1, 'big'))

def crack(a, b):
	assert len(a) == len(b)
	
	key1 = b''
	key2 = b''
	key3 = b''
	size = len(a)
	for i in range(size):
		x = '{:08b}'.format(a[i])
		y = '{:08b}'.format(b[i])
		c1,c2,c3 = find_key(x, y)
		key1 += c1
		key2 += c2
		key3 += c3
		
	return key1 + key2 + key3

def attack():
	print ('[*] Key recovery phase')
	p1 = 'ffffffffffffffffffffffffffffffff'
	p2 = '00000000000000000000000000000000'
	r.sendlineafter('? ', '1')
	r.sendlineafter(': ', p1)
	o1 = bytes.fromhex(r.recvuntil('\n')[:-1].decode())
	r.sendlineafter('? ', '1')
	r.sendlineafter(': ', p2)
	o2 = bytes.fromhex(r.recvuntil('\n')[:-1].decode())

	my_key = crack(o1, o2)
	print ('[+] key: {0}'.format(my_key.hex()))
	cipher = Cipher(my_key)

	print ('[*] Encryption phase')
	r.sendlineafter('? ', '2')
	for i in range(10):
		r.recvuntil(': ')
		inp = r.recv()[:-1]
		print('[*] Encrypting: {0}'.format(inp))
		e = cipher.encrypt(binascii.unhexlify(inp)).decode()
		r.sendline(e)

	print (r.recv())

attack()
